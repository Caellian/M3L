package cuchaz.m3l.util;

import com.google.common.base.Throwables;
import com.google.gson.*;
import cuchaz.m3l.M3L;
import cuchaz.m3l.api.versioning.ArtifactData;
import cuchaz.m3l.api.versioning.InvalidVersionFormatException;
import cuchaz.m3l.api.versioning.Version;
import cuchaz.m3l.lib.Constants;
import cuchaz.m3l.mod.ModMetadata;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.Map;

/**
 * @author Caellian
 */
public class MetadataUtil {
    public static ModMetadata[] metadataInputStream(InputStream inputStream, String sourceName) {
        if (inputStream == null) {
            return new ModMetadata[0];
        } else {
            InputStreamReader reader = new InputStreamReader(inputStream);

            try {
                Gson gson = (new GsonBuilder()).registerTypeAdapter(ArtifactData.class, new ArtifactData.ArtifactTypeAdapter()).create();
                JsonElement rootElement = new JsonParser().parse(reader);
                ModMetadata[] modList;
                if (rootElement.isJsonArray()) {
                    JsonArray jsonList = rootElement.getAsJsonArray();
                    modList = new ModMetadata[jsonList.size()];

                    for (int i = 0; i < jsonList.size(); i++) {
                        modList[i] = gson.fromJson(jsonList.get(i), ModMetadata.class);
                    }
                } else {
                    modList = gson.fromJson(rootElement, ModMetadata[].class);
                }

                parseModMetadataList(modList);
                return modList;
            } catch (JsonParseException var11) {
                M3L.LOGGER.error("The {} file in {} cannot be parsed as valid JSON. It will be ignored", Constants.METADATA_FILE, new Object[]{sourceName});
                return new ModMetadata[0];
            } catch (Exception e) {
                throw Throwables.propagate(e);
            }
        }
    }

    private static Map<String, ModMetadata> parseModMetadataList(ModMetadata[] modList) {
        HashMap<String, ModMetadata> result = new HashMap<String, ModMetadata>(0);
        for (ModMetadata modMetadata : modList) {
            result.put(modMetadata.id, modMetadata);
        }
        return result;
    }

    public static ModMetadata getMetadataForId(Map<String, ModMetadata> metadataMap, String modId, Map<String, Object> extraData) {
        //Ensure we always get a ModMetadata object back
        if (!metadataMap.containsKey(modId)) {
            ModMetadata dummy = new ModMetadata();
            dummy.id = modId;
            dummy.name = (String) extraData.get("name");
            try {
                dummy.version = Version.fromString((String) extraData.get("version"));
            } catch (InvalidVersionFormatException e) {
                dummy.version = Version.EMPTY;
            }
            dummy.autogenerated = true;
            metadataMap.put(modId, dummy);
        }

        return metadataMap.get(modId);
    }
}
